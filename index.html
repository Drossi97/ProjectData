<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Dashboard</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script>
    // Verificar que XLSX se carg√≥ correctamente
    window.addEventListener('load', function() {
      if (typeof XLSX === 'undefined') {
        console.error('XLSX no se carg√≥ correctamente, intentando fallback...');
        // Cargar desde otro CDN como fallback
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js';
        script.onload = function() {
          console.log('XLSX cargado desde fallback');
        };
        script.onerror = function() {
          console.error('Error cargando XLSX desde todos los CDNs');
          alert('Error: No se pudo cargar la librer√≠a para leer archivos Excel. Verifique su conexi√≥n a internet.');
        };
        document.head.appendChild(script);
      } else {
        console.log('XLSX cargado correctamente');
      }
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'dark-bg': '#000000',
            'dark-card': '#1A1A1A',
            'dark-sidebar': '#000000',
            'dark-border': '#333333',
            'accent-blue': '#FFFFFF',
            'accent-green': '#FFFFFF',
            'accent-purple': '#FFFFFF',
            'accent-orange': '#FFFFFF',
            'accent-pink': '#FFFFFF',
            'accent-cyan': '#FFFFFF',
            'text-primary': '#FFFFFF',
            'text-secondary': '#CCCCCC',
            'text-muted': '#888888'
          },
          keyframes: {
            'accordion-down': {
              from: { height: '0' },
              to: { height: 'var(--radix-accordion-content-height)' }
            },
            'accordion-up': {
              from: { height: 'var(--radix-accordion-content-height)' },
              to: { height: '0' }
            },
            'fade-in': {
              '0%': { opacity: '0', transform: 'translateY(10px)' },
              '100%': { opacity: '1', transform: 'translateY(0)' }
            },
            'slide-in': {
              '0%': { transform: 'translateX(-100%)' },
              '100%': { transform: 'translateX(0)' }
            }
          },
          animation: {
            'accordion-down': 'accordion-down 0.2s ease-out',
            'accordion-up': 'accordion-up 0.2s ease-out',
            'fade-in': 'fade-in 0.3s ease-out',
            'slide-in': 'slide-in 0.3s ease-out'
          }
        }
      }
    }
  </script>
  <style>
    /* Animaciones suaves para colapso/expansi√≥n */
    .table-content {
      overflow: hidden;
      transition: height 0.3s ease-out, opacity 0.2s ease-out;
    }
    
    .table-content.collapsed {
      height: 0 !important;
      opacity: 0;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
    }
    
    .table-content.expanded {
      opacity: 1;
    }
    
    /* Asegurar que no se muestren l√≠neas no deseadas en las gr√°ficas */
    canvas {
      background-color: transparent !important;
    }

    /* Estilos personalizados para el tema oscuro */
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .glass-effect {
      background: rgba(26, 26, 26, 0.8);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .card-hover {
      transition: all 0.3s ease;
    }

    .card-hover:hover {
      transform: translateY(-2px);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
    }


    .gradient-text {
      background: linear-gradient(135deg, #FFFFFF, #CCCCCC);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .stat-card {
      background: linear-gradient(135deg, rgba(26, 26, 26, 0.9), rgba(26, 26, 26, 0.7));
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .chart-container {
      background: linear-gradient(135deg, rgba(26, 26, 26, 0.9), rgba(26, 26, 26, 0.7));
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
  </style>
</head>
<body class="min-h-screen bg-dark-bg text-text-primary">


  <!-- Main Content -->
  <div class="w-full">

    <div class="p-6">
      <!-- Secci√≥n Seleccionar Archivo -->
      <div class="mb-8 glass-effect rounded-xl overflow-hidden card-hover">
        
        <div class="p-6 bg-dark-card/50">
          <div class="space-y-6">
            <div>
              <label class="block text-sm font-medium text-text-primary mb-3">Archivos Excel/CSV (m√∫ltiples)</label>
              <div class="relative">
                <input 
                  id="file" 
                  type="file" 
                  accept=".xlsx,.xls,.csv" 
                  multiple
                  class="block w-full text-sm text-text-secondary file:mr-4 file:py-3 file:px-6 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-white file:text-black hover:file:bg-gray-200 cursor-pointer border border-dark-border rounded-lg p-4 bg-dark-card/30 focus:ring-2 focus:ring-white focus:border-white transition-all duration-200"
                />
              </div>
            
              <!-- Lista de archivos cargados -->
              <div id="loaded-files" class="mt-6 hidden">
                <h3 class="text-sm font-medium text-text-primary mb-3">Archivos cargados:</h3>
                <div id="files-list" class="space-y-3"></div>
              </div>
            </div>
            
            <div id="sheet-container" class="hidden">
              <label class="block text-sm font-medium text-text-primary mb-3">Hoja de c√°lculo</label>
              <select 
                id="sheet" 
                class="block w-full px-4 py-3 border border-dark-border rounded-lg bg-dark-card/30 text-text-primary focus:ring-2 focus:ring-white focus:border-white transition-all duration-200"
              ></select>
            </div>
          
            
            <div class="flex items-center justify-between pt-6">
              <span id="info" class="text-sm text-text-muted"></span>
              <button 
                id="go" 
                disabled 
                class="inline-flex items-center px-8 py-3 text-sm font-medium rounded-lg text-black bg-white hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-white transition-all duration-200 disabled:bg-gray-400 disabled:text-gray-600 disabled:cursor-not-allowed shadow-lg"
              >
                <svg class="h-5 w-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                </svg>
                Procesar Datos
              </button>
            </div>
        </div>
      </div>
    </div>



      <!-- Dashboard de An√°lisis -->
      <div id="dashboard-content" class="hidden">

       
        <!-- Gr√°ficos -->
        <div class="mb-8 space-y-8">
          <!-- Gr√°fica de L√≠nea de Tiempo -->
          <div class="chart-container rounded-xl p-6 card-hover">
            <div class="flex justify-between items-center mb-6">
              <h3 class="text-xl font-semibold text-text-primary">L√≠nea de Tiempo de Estados</h3>
              <div class="flex gap-2">
                <button id="pan-left" class="w-10 h-10 text-sm bg-dark-card text-text-primary rounded-lg hover:bg-white hover:text-black transition-all duration-200 flex items-center justify-center border border-dark-border" title="Desplazar a la izquierda">
                  ‚Üê
                </button>
                <button id="pan-right" class="w-10 h-10 text-sm bg-dark-card text-text-primary rounded-lg hover:bg-white hover:text-black transition-all duration-200 flex items-center justify-center border border-dark-border" title="Desplazar a la derecha">
                  ‚Üí
                </button>
                <button id="zoom-in" class="w-10 h-10 text-sm bg-dark-card text-text-primary rounded-lg hover:bg-white hover:text-black transition-all duration-200 flex items-center justify-center border border-dark-border" title="Hacer zoom">
                  üîç+
                </button>
                <button id="zoom-out" class="w-10 h-10 text-sm bg-dark-card text-text-primary rounded-lg hover:bg-white hover:text-black transition-all duration-200 flex items-center justify-center border border-dark-border" title="Alejar zoom">
                  üîç-
                </button>
                <button id="reset-zoom" class="w-10 h-10 text-sm bg-dark-card text-text-primary rounded-lg hover:bg-white hover:text-black transition-all duration-200 flex items-center justify-center border border-dark-border" title="Resetear zoom">
                  ‚Üª
                </button>
              </div>
            </div>
            <div class="w-full">
              <canvas id="stateChart" class="w-full h-80 cursor-grab"></canvas>
            </div>
            
                  </div>
          
          <!-- Gr√°fico de Velocidad Media -->
          <div class="chart-container rounded-xl p-6 card-hover">
            <div class="flex justify-between items-center mb-6">
              <h3 class="text-xl font-semibold text-text-primary">Velocidad Media por Intervalos</h3>
              <div class="flex gap-2">
                <button id="speed-pan-left" class="w-10 h-10 text-sm bg-dark-card text-text-primary rounded-lg hover:bg-white hover:text-black transition-all duration-200 flex items-center justify-center border border-dark-border" title="Desplazar a la izquierda">
                  ‚Üê
                </button>
                <button id="speed-pan-right" class="w-10 h-10 text-sm bg-dark-card text-text-primary rounded-lg hover:bg-white hover:text-black transition-all duration-200 flex items-center justify-center border border-dark-border" title="Desplazar a la derecha">
                  ‚Üí
                </button>
                <button id="speed-zoom-in" class="w-10 h-10 text-sm bg-dark-card text-text-primary rounded-lg hover:bg-white hover:text-black transition-all duration-200 flex items-center justify-center border border-dark-border" title="Hacer zoom">
                  üîç+
                </button>
                <button id="speed-zoom-out" class="w-10 h-10 text-sm bg-dark-card text-text-primary rounded-lg hover:bg-white hover:text-black transition-all duration-200 flex items-center justify-center border border-dark-border" title="Alejar zoom">
                  üîç-
                </button>
                <button id="speed-reset-zoom" class="w-10 h-10 text-sm bg-dark-card text-text-primary rounded-lg hover:bg-white hover:text-black transition-all duration-200 flex items-center justify-center border border-dark-border" title="Resetear zoom">
                  ‚Üª
                </button>
                </div>
                  </div>
            <div class="w-full">
              <canvas id="speedChart" class="w-full h-80 cursor-grab"></canvas>
            </div>
          </div>
          
          <!-- Gr√°fico de Distribuci√≥n -->
          <div class="chart-container rounded-xl p-6 card-hover">
            <h3 class="text-xl font-semibold text-text-primary mb-6">Distribuci√≥n por Estados</h3>
            <div class="w-full">
              <canvas id="pieChart" class="w-full h-80"></canvas>
            </div>
          </div>
      </div>
      
        <!-- Tabla de Detalles -->
        <div class="chart-container rounded-xl p-6 card-hover">
          <h3 class="text-xl font-semibold text-text-primary mb-6">Tabla de Datos Detallados</h3>
          <div class="border border-dark-border rounded-lg bg-dark-card/30">
            <div class="overflow-x-auto overflow-y-auto max-h-[600px]">
              <table id="table" class="min-w-full table-auto whitespace-nowrap"></table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
// Plugin para mostrar gaps/saltos en los datos y eventos del barco
Chart.register({
  id: 'dataGaps',
  beforeDatasetsDraw: function(chart, args, options) {
    const ctx = chart.ctx;
    const chartArea = chart.chartArea;
    const xScale = chart.scales.x;
    const yScale = chart.scales.y;
    
    ctx.save();
    
    // Dibujar gaps de datos
    if (chart.gaps && chart.gaps.length > 0) {
      chart.gaps.forEach(gap => {
        const startX = xScale.getPixelForValue(gap.start);
        const endX = xScale.getPixelForValue(gap.end);
        
        // Dibujar zona oscura para indicar falta de datos
        ctx.fillStyle = 'rgba(128, 128, 128, 0.2)';
        ctx.fillRect(startX, chartArea.top, endX - startX, chartArea.bottom - chartArea.top);
        
        // Dibujar l√≠neas punteadas en los bordes
        ctx.strokeStyle = 'rgba(128, 128, 128, 0.6)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        
        // L√≠nea izquierda
        ctx.beginPath();
        ctx.moveTo(startX, chartArea.top);
        ctx.lineTo(startX, chartArea.bottom);
        ctx.stroke();
        
        // L√≠nea derecha
        ctx.beginPath();
        ctx.moveTo(endX, chartArea.top);
        ctx.lineTo(endX, chartArea.bottom);
        ctx.stroke();
        
        // Etiqueta "SIN DATOS" en el centro del gap si es lo suficientemente ancho
        const gapWidth = endX - startX;
        if (gapWidth > 80) {
          ctx.fillStyle = 'rgba(128, 128, 128, 0.8)';
          ctx.font = 'bold 11px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          const centerX = startX + gapWidth / 2;
          const centerY = chartArea.top + (chartArea.bottom - chartArea.top) / 2;
          
          // Fondo para el texto
          const textWidth = ctx.measureText('SIN DATOS').width;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.fillRect(centerX - textWidth/2 - 4, centerY - 8, textWidth + 8, 16);
          
          // Texto
          ctx.fillStyle = 'rgba(128, 128, 128, 0.9)';
          ctx.fillText('SIN DATOS', centerX, centerY);
        }
        
        ctx.setLineDash([]);
      });
    }
    
    
    ctx.restore();
  }
});

const $ = (s)=>document.querySelector(s);
const fileInput = $('#file');
const sheetSel = $('#sheet');
const sheetContainer = $('#sheet-container');
const goBtn = $('#go');
const info = $('#info');
const outTable = $('#table');
const dashboardContent = $('#dashboard-content');
const chartCanvas = $('#stateChart');
const pieChartCanvas = $('#pieChart');
const speedChartCanvas = $('#speedChart');
const panLeftBtn = $('#pan-left');
const panRightBtn = $('#pan-right');
const zoomInBtn = $('#zoom-in');
const zoomOutBtn = $('#zoom-out');
const resetZoomBtn = $('#reset-zoom');

const speedPanLeftBtn = $('#speed-pan-left');
const speedPanRightBtn = $('#speed-pan-right');
const speedZoomInBtn = $('#speed-zoom-in');
const speedZoomOutBtn = $('#speed-zoom-out');
const speedResetZoomBtn = $('#speed-reset-zoom');

const loadedFilesContainer = $('#loaded-files');
const filesList = $('#files-list');

 let stateChart = null;
 let pieChart = null;
 let speedChart = null;
 let originalIntervals = []; // Guardar los intervalos originales para referencia

// Variables para manejar m√∫ltiples archivos
let loadedFiles = []; // Array de objetos {name, data, hash}
let UNIFIED_DATA = []; // Datos unificados de todos los archivos


// Funci√≥n para mostrar/ocultar el dashboard
function toggleDashboard(show) {
  if (show) {
    dashboardContent.classList.remove('hidden');
  } else {
    dashboardContent.classList.add('hidden');
  }
}

// Funciones de control de zoom y pan
function setupZoomControls() {
  // Controles para el gr√°fico de estados
  panLeftBtn.addEventListener('click', () => {
    if (stateChart) {
      stateChart.pan({x: 50, y: 0}, undefined, 'default');
    }
  });
  
  panRightBtn.addEventListener('click', () => {
    if (stateChart) {
      stateChart.pan({x: -50, y: 0}, undefined, 'default');
    }
  });
  
  zoomInBtn.addEventListener('click', () => {
    if (stateChart) {
      stateChart.zoom(1.2);
    }
  });
  
  zoomOutBtn.addEventListener('click', () => {
    if (stateChart) {
      stateChart.zoom(0.8);
    }
  });
  
  resetZoomBtn.addEventListener('click', () => {
    if (stateChart) {
      stateChart.resetZoom();
    }
  });

  // Controles para el gr√°fico de velocidad
  speedPanLeftBtn.addEventListener('click', () => {
    if (speedChart) {
      speedChart.pan({x: 50, y: 0}, undefined, 'default');
    }
  });
  
  speedPanRightBtn.addEventListener('click', () => {
    if (speedChart) {
      speedChart.pan({x: -50, y: 0}, undefined, 'default');
    }
  });
  
  speedZoomInBtn.addEventListener('click', () => {
    if (speedChart) {
      speedChart.zoom(1.2);
    }
  });
  
  speedZoomOutBtn.addEventListener('click', () => {
    if (speedChart) {
      speedChart.zoom(0.8);
    }
  });
  
  speedResetZoomBtn.addEventListener('click', () => {
    if (speedChart) {
      speedChart.resetZoom();
    }
  });
}








// Colores para los estados (paleta colorida para mejor visualizaci√≥n)
function getStateColorChart(state) {
  switch(state) {
    case 0: return { bg: 'rgba(156, 163, 175, 0.8)', border: 'rgb(156, 163, 175)' }; // gray
    case 1: return { bg: 'rgba(34, 197, 94, 0.8)', border: 'rgb(34, 197, 94)' }; // green
    case 2: return { bg: 'rgba(59, 130, 246, 0.8)', border: 'rgb(59, 130, 246)' }; // blue
    case 3: return { bg: 'rgba(245, 158, 11, 0.8)', border: 'rgb(245, 158, 11)' }; // orange
    case 4: return { bg: 'rgba(239, 68, 68, 0.8)', border: 'rgb(239, 68, 68)' }; // red
    case 5: return { bg: 'rgba(139, 92, 246, 0.8)', border: 'rgb(139, 92, 246)' }; // purple
    case 6: return { bg: 'rgba(236, 72, 153, 0.8)', border: 'rgb(236, 72, 153)' }; // pink
    case 7: return { bg: 'rgba(6, 182, 212, 0.8)', border: 'rgb(6, 182, 212)' }; // cyan
    case 8: return { bg: 'rgba(132, 204, 22, 0.8)', border: 'rgb(132, 204, 22)' }; // lime
    default: return { bg: 'rgba(107, 114, 128, 0.8)', border: 'rgb(107, 114, 128)' }; // default gray
  }
}

// Funci√≥n para generar hash de archivo (para detectar duplicados)
function generateFileHash(content, fileName) {
  // Crear hash simple basado en contenido y nombre
  let hash = 0;
  const str = fileName + content.substring(0, 1000); // Usar nombre + primeros 1000 chars
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash).toString(36);
}

// Funci√≥n para verificar si un archivo ya est√° cargado
function isFileDuplicate(fileContent, fileName) {
  const newHash = generateFileHash(fileContent, fileName);
  return loadedFiles.some(file => file.hash === newHash);
}

// Funci√≥n para mostrar la lista de archivos cargados
function updateFilesList() {
  if (loadedFiles.length === 0) {
    loadedFilesContainer.classList.add('hidden');
    return;
  }
  
  loadedFilesContainer.classList.remove('hidden');
  filesList.innerHTML = '';
  
  loadedFiles.forEach((file, index) => {
    const fileItem = document.createElement('div');
    fileItem.className = 'flex items-center justify-between p-4 bg-dark-card/30 rounded-lg border border-dark-border hover:bg-dark-card/50 transition-all duration-200';
    fileItem.innerHTML = `
      <div class="flex items-center">
        <svg class="w-5 h-5 text-white mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <span class="text-sm text-text-primary font-medium">${file.name}</span>
        <span class="ml-3 px-3 py-1 text-xs bg-white/20 text-white rounded-full border border-white/30">${file.recordCount} registros</span>
      </div>
      <button onclick="removeFile(${index})" class="text-gray-400 hover:text-white transition-colors p-1 rounded hover:bg-white/10">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    `;
    filesList.appendChild(fileItem);
  });
}

// Funci√≥n para eliminar un archivo espec√≠fico
function removeFile(index) {
  loadedFiles.splice(index, 1);
  updateFilesList();
  updateUnifiedData();
  updateProcessButton();
}

// Funci√≥n para limpiar todos los archivos
function clearAllFiles() {
  loadedFiles = [];
  UNIFIED_DATA = [];
  updateFilesList();
  updateProcessButton();
  // Ocultar resultados
  toggleDashboard(false);
  sheetContainer.classList.add('hidden');
}

// Funci√≥n para unificar datos de todos los archivos
function updateUnifiedData() {
  UNIFIED_DATA = [];
  
  // Combinar todos los datos de los archivos
  loadedFiles.forEach(file => {
    UNIFIED_DATA = UNIFIED_DATA.concat(file.data);
  });
  
  // Ordenar por fecha
  UNIFIED_DATA.sort((a, b) => a.date - b.date);
}



// Funci√≥n para actualizar el estado del bot√≥n procesar
function updateProcessButton() {
  if (loadedFiles.length > 0) {
    goBtn.disabled = false;
    info.textContent = ''; // Ocultar texto cuando hay archivos
  } else {
    goBtn.disabled = true;
    info.textContent = 'Selecciona archivos para comenzar';
  }
}

// Funci√≥n para generar rango de fechas
function getDateRange(intervals) {
  if (!intervals.length) return '';
  
  // Obtener fechas m√≠nima y m√°xima
  let minDate = intervals[0].start;
  let maxDate = intervals[0].end;
  
  intervals.forEach(interval => {
    if (interval.start < minDate) minDate = interval.start;
    if (interval.end > maxDate) maxDate = interval.end;
  });
  
  const minDateStr = formatDate(minDate);
  const maxDateStr = formatDate(maxDate);
  
  // Si es el mismo d√≠a, mostrar solo una fecha
  if (minDateStr === maxDateStr) {
    return minDateStr;
  } else {
    return `${minDateStr} - ${maxDateStr}`;
  }
}

function createPieChart(intervals) {
  if (!intervals.length) return;
  
  // Funci√≥n para detectar gaps entre intervalos
  function detectGaps(intervals) {
    const gaps = [];
    for (let i = 1; i < intervals.length; i++) {
      const prevEnd = intervals[i-1].end.getTime();
      const currentStart = intervals[i].start.getTime();
      const gapDuration = currentStart - prevEnd;
      
      // Solo gaps ‚â• 5 minutos son significativos
      if (gapDuration >= 5 * 60 * 1000) {
        gaps.push({
          start: prevEnd,
          end: currentStart,
          duration: gapDuration
        });
      }
    }
    return gaps;
  }
  
  // Calcular tiempo total por estado, excluyendo gaps
  const stateData = {};
  const stateDurations = {};
  let totalTime = 0;
  let totalGapTime = 0;
  
  // Detectar gaps entre intervalos
  const gaps = detectGaps(intervals);
  
  intervals.forEach((interval, index) => {
    // Calcular duraci√≥n real del intervalo
    let intervalDuration = interval.end.getTime() - interval.start.getTime();
    
    // Verificar si hay un gap despu√©s de este intervalo
    const nextInterval = intervals[index + 1];
    if (nextInterval) {
      const gapAfter = nextInterval.start.getTime() - interval.end.getTime();
      if (gapAfter > 5 * 60 * 1000) {
        // Hay un gap significativo despu√©s de este intervalo
        console.log(`Gap detectado despu√©s del intervalo ${index}: ${(gapAfter / (1000 * 60)).toFixed(1)} minutos`);
        totalGapTime += gapAfter;
      }
    }
    
    const durationSeconds = Math.round(intervalDuration / 1000);
    
    if (!stateData[interval.state]) {
      stateData[interval.state] = 0;
      stateDurations[interval.state] = 0;
    }
    stateData[interval.state] += durationSeconds;
    stateDurations[interval.state] += durationSeconds;
    totalTime += durationSeconds;
  });
  
  console.log(`Tiempo total de datos: ${(totalTime / 60).toFixed(1)} min, Tiempo total de gaps: ${(totalGapTime / (1000 * 60)).toFixed(1)} min`);
  
  // Preparar datos para el gr√°fico de pie
  const labels = [];
  const data = [];
  const backgroundColors = [];
  const borderColors = [];
  
  Object.keys(stateData).sort((a, b) => parseInt(a) - parseInt(b)).forEach(state => {
    const stateNum = parseInt(state);
    const durationSeconds = stateData[state];
    const percentage = ((durationSeconds / totalTime) * 100).toFixed(1);
    
    labels.push(`Estado ${stateNum}`);
    data.push(durationSeconds);
    
    const colors = getStateColorChart(stateNum);
    backgroundColors.push(colors.bg);
    borderColors.push(colors.border);
  });
  
  // Destruir gr√°fica existente si existe
  if (pieChart) {
    pieChart.destroy();
  }
  
  const ctx = pieChartCanvas.getContext('2d');
  pieChart = new Chart(ctx, {
    type: 'pie',
    data: {
      labels: labels,
      datasets: [{
        data: data,
        backgroundColor: backgroundColors,
        borderColor: borderColors,
        borderWidth: 2
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: false // Ocultar la leyenda
        },
        tooltip: {
          backgroundColor: 'white',
          titleColor: 'rgb(31, 41, 55)',
          bodyColor: 'rgb(31, 41, 55)',
          borderColor: 'rgb(209, 213, 219)',
          borderWidth: 1,
          cornerRadius: 6,
          displayColors: false,
          padding: 12,
          boxShadow: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
          titleFont: {
            size: 14,
            weight: '600'
          },
          bodyFont: {
            size: 13,
            weight: '500'
          },
          callbacks: {
            title: function(context) {
              return context[0].label;
            },
            label: function(context) {
              const durationSeconds = context.parsed;
              const percentage = ((durationSeconds / totalTime) * 100).toFixed(1);
              // Usar formato din√°mico igual que las otras gr√°ficas
              const timeFormatted = formatDynamicDuration(durationSeconds);
              return [`Duraci√≥n: ${timeFormatted}`, `Porcentaje: ${percentage}%`];
            }
          }
        }
      }
    }
  });
}

function createSpeedChart(intervals) {
  if (!intervals.length) return;
  
  // Guardar todos los intervalos para referencia (no solo los que tienen velocidad)
  originalSpeedIntervals = intervals;
  
  // Preparar datos para el gr√°fico usando TODOS los intervalos
  const speedData = [];
  const baseTime = intervals[0].start.getTime();
  
  // Crear datos con interrupciones expl√≠citas en gaps
  intervals.forEach((interval, index) => {
    const startTime = interval.start.getTime();
    const endTime = interval.end.getTime();
    
    // Calcular minutos desde el inicio para posicionamiento
    const startMinutes = (startTime - baseTime) / (1000 * 60);
    const endMinutes = (endTime - baseTime) / (1000 * 60);
    
    // Verificar si hay gap con el intervalo anterior
    let hasGap = false;
    if (index > 0) {
      const prevEnd = intervals[index-1].end.getTime();
      const gapDuration = startTime - prevEnd;
      hasGap = gapDuration >= 5 * 60 * 1000; // Gap ‚â• 5 minutos
    }
    
    // Si hay gap, a√±adir punto null para interrumpir la l√≠nea
    if (hasGap) {
      speedData.push({
        x: startMinutes - 0.01, // Justo antes del nuevo intervalo
        y: null // Valor null interrumpe la l√≠nea
      });
    }
    
    // Usar velocidad del intervalo, o 0 si no hay datos
    const speedValue = (interval.avgSpeed !== null && interval.avgSpeed !== undefined && !isNaN(interval.avgSpeed)) 
      ? interval.avgSpeed 
      : 0;
    
    // A√±adir puntos del intervalo
    speedData.push({
      x: startMinutes,
      y: speedValue,
      state: interval.state,
      startTime: formatTime(interval.start),
      endTime: formatTime(interval.end),
      duration: calculateVisualDuration(interval.start, interval.end),
      realStartTime: interval.start,
      realEndTime: interval.end,
      hasSpeedData: interval.avgSpeed !== null && interval.avgSpeed !== undefined && !isNaN(interval.avgSpeed)
    });
    
    speedData.push({
      x: endMinutes,
      y: speedValue,
      state: interval.state,
      startTime: formatTime(interval.start),
      endTime: formatTime(interval.end),
      duration: calculateVisualDuration(interval.start, interval.end),
      realStartTime: interval.start,
      realEndTime: interval.end,
      hasSpeedData: interval.avgSpeed !== null && interval.avgSpeed !== undefined && !isNaN(interval.avgSpeed)
    });
  });
  
  // Detectar gaps/saltos en los datos bas√°ndose en fechas completas (igual que en el gr√°fico de estados)
  const gaps = [];
  
  // Primero detectar gaps entre intervalos (mismo d√≠a)
  for (let i = 1; i < intervals.length; i++) {
    const prevEnd = intervals[i-1].end.getTime();
    const currentStart = intervals[i].start.getTime();
    const gapDuration = currentStart - prevEnd;
    
    // Solo gaps ‚â• 5 minutos son significativos
    if (gapDuration >= 5 * 60 * 1000) {
      const gapStartMinutes = (prevEnd - baseTime) / (1000 * 60);
      const gapEndMinutes = (currentStart - baseTime) / (1000 * 60);
      
      gaps.push({
        start: gapStartMinutes,
        end: gapEndMinutes,
        duration: gapDuration
      });
    }
  }
  
  // Detectar gaps de d√≠as completos
  if (intervals.length > 0) {
    const startDate = new Date(intervals[0].start);
    const endDate = new Date(intervals[intervals.length - 1].end);
    
    // Crear un set de fechas con datos
    const datesWithData = new Set();
    intervals.forEach(interval => {
      const dateStr = formatDate(interval.start);
      datesWithData.add(dateStr);
      // Tambi√©n agregar fecha de fin si es diferente
      const endDateStr = formatDate(interval.end);
      if (endDateStr !== dateStr) {
        datesWithData.add(endDateStr);
      }
    });
    
    // Recorrer todas las fechas en el rango y detectar d√≠as sin datos
    const currentDate = new Date(startDate);
    currentDate.setHours(0, 0, 0, 0);
    
    while (currentDate <= endDate) {
      const dateStr = formatDate(currentDate);
      if (!datesWithData.has(dateStr)) {
        // Este d√≠a no tiene datos, crear gap para todo el d√≠a
        const dayStart = new Date(currentDate);
        const dayEnd = new Date(currentDate);
        dayEnd.setHours(23, 59, 59, 999);
        
        const gapStartMinutes = (dayStart.getTime() - baseTime) / (1000 * 60);
        const gapEndMinutes = (dayEnd.getTime() - baseTime) / (1000 * 60);
        
        gaps.push({
          start: gapStartMinutes,
          end: gapEndMinutes,
          duration: 24 * 60 * 60 * 1000 // 24 horas en ms
        });
      }
      
      // Avanzar al siguiente d√≠a
      currentDate.setDate(currentDate.getDate() + 1);
    }
  }
  
  // Destruir gr√°fica existente si existe
  if (speedChart) {
    speedChart.destroy();
  }
  
  const ctx = speedChartCanvas.getContext('2d');
  speedChart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [{
        label: 'Velocidad Media',
        data: speedData,
        borderColor: 'rgb(34, 197, 94)',
        backgroundColor: 'rgba(34, 197, 94, 0.1)',
        borderWidth: 3,
        stepped: true,
        fill: true,
        pointRadius: 0,
        pointHoverRadius: 0,
        pointBorderWidth: 0,
        tension: 0,
        order: 2,
        spanGaps: false // No conectar gaps
      }, {
        label: 'Cursor',
        data: [], // Se llenar√° din√°micamente
        borderColor: 'transparent',
        backgroundColor: 'transparent',
        pointRadius: 10,
        pointHoverRadius: 10,
        pointBorderWidth: 3,
        pointBorderColor: 'white',
        pointBackgroundColor: 'rgb(34, 197, 94)',
        showLine: false,
        pointHitRadius: 0,
        order: 3
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          type: 'linear',
          position: 'bottom',
          title: {
            display: true,
            text: 'Tiempo (HH:MM:SS)',
            color: 'rgb(255, 255, 255)',
            font: {
              size: 14,
              weight: '600'
            }
          },
          grid: {
            color: 'rgba(255, 255, 255, 0.1)',
            drawBorder: false
          },
          ticks: {
            callback: function(value, index, values) {
              const startTime = new Date(baseTime + value * 60 * 1000);
              const timeStr = getFormattedTime(startTime);
              const currentDate = formatDate(startTime);
              
              // Para el primer tick, siempre mostrar la fecha
              if (index === 0) {
                return [timeStr, `üìÖ ${currentDate}`];
              }
              
              // Para otros ticks, verificar si hay cambio de d√≠a
              if (index > 0 && values[index - 1] !== undefined) {
                const prevTime = new Date(baseTime + values[index - 1].value * 60 * 1000);
                const prevDate = formatDate(prevTime);
                
                if (currentDate !== prevDate) {
                  return [timeStr, `üìÖ ${currentDate}`];
                }
              }
              
              return timeStr;
            },
            maxTicksLimit: 15,
            font: {
              size: 12,
              weight: '500'
            },
            color: 'rgb(255, 255, 255)'
          }
        },
        y: {
          title: {
            display: true,
            text: 'Velocidad (nudos)',
            color: 'rgb(255, 255, 255)',
            font: {
              size: 14,
              weight: '600'
            }
          },
          grid: {
            color: 'rgba(255, 255, 255, 0.1)',
            drawBorder: false
          },
          beginAtZero: true,
          ticks: {
            callback: function(value) {
              return `${value.toFixed(1)} kn`;
            },
            font: {
              size: 12,
              weight: '500'
            },
            color: 'rgb(255, 255, 255)'
          }
        }
      },
      plugins: {
        tooltip: {
          enabled: false // Deshabilitar tooltips autom√°ticos para usar tooltips personalizados
        },
        legend: {
          display: false
        },
        dataGaps: true, // Habilitar el plugin de gaps
        zoom: {
          zoom: {
            wheel: {
              enabled: false
            },
            pinch: {
              enabled: false
            },
            mode: 'x'
          },
          pan: {
            enabled: true,
            mode: 'x',
            modifierKey: null,
            onPanStart: function(context) {
              context.chart.canvas.style.cursor = 'grabbing';
            },
            onPanComplete: function(context) {
              context.chart.canvas.style.cursor = 'grab';
            }
          }
        }
      },
      interaction: {
        intersect: false,
        mode: 'index'
      },
      onHover: function(event, elements) {
        const canvasX = event.native.offsetX;
        const xScale = speedChart.scales.x;
        const xValue = xScale ? xScale.getValueForPixel(canvasX) : null;
        
        // No mostrar punto din√°mico si estamos en un gap
        if (xValue !== null && isInGap(xValue, speedChart)) {
          speedChart.data.datasets[1].data = [];
          speedChart.update('none');
          return;
        }
        
        updateSpeedDynamicPoint(event);
      },
      onClick: function(event, elements) {
        const canvasX = event.native.offsetX;
        const xScale = speedChart.scales.x;
        const xValue = xScale ? xScale.getValueForPixel(canvasX) : null;
        
        // No mostrar tooltip si estamos en un gap
        if (xValue !== null && isInGap(xValue, speedChart)) {
          hideSpeedCustomTooltip();
          return;
        }
        
        const pointData = getSpeedDynamicPointData(event);
        if (pointData) {
          showSpeedCustomTooltip(event, pointData);
        } else {
          hideSpeedCustomTooltip();
        }
      }
    }
  });
  
  // Debug: mostrar gaps detectados
  console.log('Gaps detectados en gr√°fico de velocidad:', gaps);
  
  // Asignar gaps al chart para que el plugin pueda acceder a ellos
  speedChart.gaps = gaps;
  speedChart.baseTime = baseTime;
}

function createChart(intervals) {
   if (!intervals.length) return;
   
   // Guardar los intervalos originales para usar en el mouse move
   originalIntervals = intervals;
  
  // Preparar datos para Chart.js usando timestamps reales
  const chartData = [];
  
  // Obtener el timestamp base (primer punto) para calcular minutos relativos
  const baseTime = intervals[0].start.getTime();
  
  // Detectar gaps/saltos en los datos bas√°ndose en fechas completas
  const gaps = [];
  
  // Primero detectar gaps entre intervalos (mismo d√≠a)
  for (let i = 1; i < intervals.length; i++) {
    const prevEnd = intervals[i-1].end.getTime();
    const currentStart = intervals[i].start.getTime();
    const gapDuration = currentStart - prevEnd;
    
    // Solo gaps ‚â• 5 minutos son significativos
    if (gapDuration >= 5 * 60 * 1000) {
      const gapStartMinutes = (prevEnd - baseTime) / (1000 * 60);
      const gapEndMinutes = (currentStart - baseTime) / (1000 * 60);
      
      gaps.push({
        start: gapStartMinutes,
        end: gapEndMinutes,
        duration: gapDuration
      });
    }
  }
  
  // Detectar gaps de d√≠as completos
  if (intervals.length > 0) {
    const startDate = new Date(intervals[0].start);
    const endDate = new Date(intervals[intervals.length - 1].end);
    
    // Crear un set de fechas con datos
    const datesWithData = new Set();
    intervals.forEach(interval => {
      const dateStr = formatDate(interval.start);
      datesWithData.add(dateStr);
      // Tambi√©n agregar fecha de fin si es diferente
      const endDateStr = formatDate(interval.end);
      if (endDateStr !== dateStr) {
        datesWithData.add(endDateStr);
      }
    });
    
    // Recorrer todas las fechas en el rango y detectar d√≠as sin datos
    const currentDate = new Date(startDate);
    currentDate.setHours(0, 0, 0, 0);
    
    while (currentDate <= endDate) {
      const dateStr = formatDate(currentDate);
      if (!datesWithData.has(dateStr)) {
        // Este d√≠a no tiene datos, crear gap para todo el d√≠a
        const dayStart = new Date(currentDate);
        const dayEnd = new Date(currentDate);
        dayEnd.setHours(23, 59, 59, 999);
        
        const gapStartMinutes = (dayStart.getTime() - baseTime) / (1000 * 60);
        const gapEndMinutes = (dayEnd.getTime() - baseTime) / (1000 * 60);
        
        gaps.push({
          start: gapStartMinutes,
          end: gapEndMinutes,
          duration: 24 * 60 * 60 * 1000 // 24 horas en ms
        });
      }
      
      // Avanzar al siguiente d√≠a
      currentDate.setDate(currentDate.getDate() + 1);
    }
  }
  

  
  // Crear datos con interrupciones expl√≠citas en gaps
  intervals.forEach((interval, index) => {
    const startTime = interval.start.getTime();
    const endTime = interval.end.getTime();
    
    // Calcular minutos desde el inicio para posicionamiento real
    const startMinutes = (startTime - baseTime) / (1000 * 60);
    const endMinutes = (endTime - baseTime) / (1000 * 60);
    
    // Verificar si hay gap con el intervalo anterior
    let hasGap = false;
    if (index > 0) {
      const prevEnd = intervals[index-1].end.getTime();
      const gapDuration = startTime - prevEnd;
      hasGap = gapDuration >= 5 * 60 * 1000; // Gap ‚â• 5 minutos
    }
    
    // Si hay gap, a√±adir punto null para interrumpir la l√≠nea
    if (hasGap) {
      chartData.push({
        x: startMinutes - 0.01, // Justo antes del nuevo intervalo
        y: null // Valor null interrumpe la l√≠nea
      });
    }
    
    // A√±adir puntos del intervalo
    chartData.push({
      x: startMinutes,
      y: interval.state,
      duration: calculateVisualDuration(interval.start, interval.end),
      startTime: formatTime(interval.start),
      endTime: formatTime(interval.end),
      realStartTime: interval.start,
      realEndTime: interval.end
    });
    
    chartData.push({
      x: endMinutes,
      y: interval.state,
      duration: calculateVisualDuration(interval.start, interval.end),
      startTime: formatTime(interval.start),
      endTime: formatTime(interval.end),
      realStartTime: interval.start,
      realEndTime: interval.end
    });
  });
  

  
  // Destruir gr√°fica existente si existe
  if (stateChart) {
    stateChart.destroy();
  }
  
     const ctx = chartCanvas.getContext('2d');
   stateChart = new Chart(ctx, {
     type: 'line',
     data: {
       datasets: [{
         label: 'Estado',
         data: chartData,
         borderColor: 'rgb(59, 130, 246)',
         backgroundColor: 'rgba(59, 130, 246, 0.1)',
         borderWidth: 3,
         stepped: true,
         fill: true,
         pointRadius: 0,
         pointHoverRadius: 0,
         pointBorderWidth: 0,
         order: 2,
         spanGaps: false // No conectar gaps
       }, {
         label: 'Cursor',
         data: [], // Se llenar√° din√°micamente
         borderColor: 'transparent',
         backgroundColor: 'transparent',
         pointRadius: 10,
         pointHoverRadius: 10,
         pointBorderWidth: 3,
         pointBorderColor: 'white',
         pointBackgroundColor: 'rgb(59, 130, 246)',
         showLine: false,
         pointHitRadius: 0,
         order: 3
       }]
     },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          type: 'linear',
          position: 'bottom',
          title: {
            display: true,
            text: 'Tiempo (HH:MM:SS)',
            color: 'rgb(255, 255, 255)',
            font: {
              size: 14,
              weight: '600'
            }
          },
          grid: {
            color: 'rgba(255, 255, 255, 0.1)',
            drawBorder: false
          },
          ticks: {
            callback: function(value, index, values) {
              const startTime = new Date(baseTime + value * 60 * 1000);
              const timeStr = getFormattedTime(startTime);
              const currentDate = formatDate(startTime);
              
              // Para el primer tick, siempre mostrar la fecha
              if (index === 0) {
                return [timeStr, `üìÖ ${currentDate}`];
              }
              
              // Para otros ticks, verificar si hay cambio de d√≠a
              if (index > 0 && values[index - 1] !== undefined) {
                const prevTime = new Date(baseTime + values[index - 1].value * 60 * 1000);
                const prevDate = formatDate(prevTime);
                
                if (currentDate !== prevDate) {
                  return [timeStr, `üìÖ ${currentDate}`];
                }
              }
              
              return timeStr;
            },
            maxTicksLimit: 15,
            font: {
              size: 12,
              weight: '500'
            },
            color: 'rgb(255, 255, 255)'
          }
        },
        y: {
          title: {
            display: true,
            text: 'Estado',
            color: 'rgb(255, 255, 255)',
            font: {
              size: 14,
              weight: '600'
            }
          },
          grid: {
            color: 'rgba(255, 255, 255, 0.1)',
            drawBorder: false
          },
          beginAtZero: true,
          ticks: {
            stepSize: 1,
            callback: function(value) {
              return `Estado ${value}`;
            },
            font: {
              size: 12,
              weight: '500'
            },
            color: 'rgb(255, 255, 255)'
          }
        }
      },
      plugins: {
        tooltip: {
          enabled: false // Deshabilitar tooltips autom√°ticos
        },
        legend: {
          display: false
        },
        dataGaps: true,
        zoom: {
          zoom: {
            wheel: {
              enabled: false
            },
            pinch: {
              enabled: false
            },
            mode: 'x'
          },
          pan: {
            enabled: true,
            mode: 'x',
            modifierKey: null,
            onPanStart: function(context) {
              context.chart.canvas.style.cursor = 'grabbing';
            },
            onPanComplete: function(context) {
              context.chart.canvas.style.cursor = 'grab';
            }
          }
        }
      },
             interaction: {
         intersect: false,
         mode: 'index'
       },
       onHover: function(event, elements) {
         const canvasX = event.native.offsetX;
         const xScale = stateChart.scales.x;
         const xValue = xScale ? xScale.getValueForPixel(canvasX) : null;
         
         // No mostrar punto din√°mico si estamos en un gap
         if (xValue !== null && isInGap(xValue, stateChart)) {
           stateChart.data.datasets[1].data = [];
           stateChart.update('none');
           return;
         }
         
         updateDynamicPoint(event);
       },
       onClick: function(event, elements) {
         const canvasX = event.native.offsetX;
         const xScale = stateChart.scales.x;
         const xValue = xScale ? xScale.getValueForPixel(canvasX) : null;
         
         // No mostrar tooltip si estamos en un gap
         if (xValue !== null && isInGap(xValue, stateChart)) {
           hideCustomTooltip();
           return;
         }
         
         const pointData = getDynamicPointData(event);
         if (pointData) {
           showCustomTooltip(event, pointData);
         } else {
           hideCustomTooltip();
         }
       }
    }
  });
  
  // Debug: mostrar gaps detectados
  console.log('Gaps detectados:', gaps);
  
  // Asignar gaps al chart para que el plugin pueda acceder a ellos
  stateChart.gaps = gaps;
  stateChart.baseTime = baseTime;
}

// Funci√≥n para actualizar el punto din√°mico
function updateDynamicPoint(event) {
  if (!stateChart || !originalIntervals.length) return;
  
  // Obtener coordenadas del mouse
  const canvasX = event.native.offsetX;
  const xScale = stateChart.scales.x;
  
  if (!xScale) return;
  
  // Convertir coordenada X a valor de tiempo
  const xValue = xScale.getValueForPixel(canvasX);
  
  // Buscar el intervalo correspondiente
  const baseTime = originalIntervals[0].start.getTime();
  let targetInterval = null;
  
  for (let i = 0; i < originalIntervals.length; i++) {
    const interval = originalIntervals[i];
    const startMinutes = (interval.start.getTime() - baseTime) / (1000 * 60);
    const endMinutes = (interval.end.getTime() - baseTime) / (1000 * 60);
    
    if (xValue >= startMinutes && xValue <= endMinutes) {
      targetInterval = interval;
      break;
    }
  }
  
  if (targetInterval) {
    // Actualizar el dataset del punto din√°mico
    stateChart.data.datasets[1].data = [{
      x: xValue,
      y: targetInterval.state
    }];
    stateChart.update('none'); // Sin animaci√≥n para fluidez
  } else {
    // Ocultar punto si no hay intervalo
    stateChart.data.datasets[1].data = [];
    stateChart.update('none');
  }
}

// Funci√≥n para obtener datos del punto din√°mico
function getDynamicPointData(event) {
  if (!originalIntervals.length) return null;
  
  const canvasX = event.native.offsetX;
  const xScale = stateChart.scales.x;
  
  if (!xScale) return null;
  
  const xValue = xScale.getValueForPixel(canvasX);
  const baseTime = originalIntervals[0].start.getTime();
  
  for (let i = 0; i < originalIntervals.length; i++) {
    const interval = originalIntervals[i];
    const startMinutes = (interval.start.getTime() - baseTime) / (1000 * 60);
    const endMinutes = (interval.end.getTime() - baseTime) / (1000 * 60);
    
    if (xValue >= startMinutes && xValue <= endMinutes) {
      const duration = interval.end.getTime() - interval.start.getTime();
      return {
        y: interval.state,
        startTime: formatTime(interval.start),
        endTime: formatTime(interval.end),
        duration: calculateVisualDuration(interval.start, interval.end),
        realStartTime: interval.start,
        realEndTime: interval.end,
        avgSpeed: interval.avgSpeed // Incluir velocidad media del intervalo
      };
    }
  }
  
  return null;
}

// Variables para tooltip personalizado
let customTooltip = null;

// Funci√≥n para verificar si una coordenada X est√° dentro de un gap
function isInGap(xValue, chart) {
  if (!chart.gaps || !chart.gaps.length) return false;
  
  return chart.gaps.some(gap => xValue >= gap.start && xValue <= gap.end);
}

// Funci√≥n para mostrar tooltip personalizado
function showCustomTooltip(event, dataPoint) {
  console.log('Mostrando tooltip para:', dataPoint); // Debug
  hideCustomTooltip(); // Ocultar tooltip anterior si existe
  
  // Verificar que tenemos datos v√°lidos
  if (!dataPoint || dataPoint.y === undefined) {
    console.log('Datos del punto inv√°lidos'); // Debug
    return;
  }
  
  // Crear elemento tooltip
  customTooltip = document.createElement('div');
  customTooltip.style.position = 'fixed'; // Usar fixed en lugar de absolute
  customTooltip.style.backgroundColor = 'white';
  customTooltip.style.color = 'rgb(55, 65, 81)';
  customTooltip.style.padding = '8px 12px';
  customTooltip.style.borderRadius = '6px';
  customTooltip.style.fontSize = '14px';
  customTooltip.style.fontWeight = '500';
  customTooltip.style.border = '1px solid rgb(209, 213, 219)';
  customTooltip.style.boxShadow = '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)';
  customTooltip.style.zIndex = '1000';
  customTooltip.style.pointerEvents = 'none';
  customTooltip.style.whiteSpace = 'nowrap';
  
  // Formatear velocidad media
  const speedDisplay = dataPoint.avgSpeed !== null && dataPoint.avgSpeed !== undefined && !isNaN(dataPoint.avgSpeed) 
    ? `${dataPoint.avgSpeed.toFixed(2)} nudos` 
    : 'N/A';
  
  // Contenido del tooltip
  const timeRange = formatTimeRange(dataPoint.realStartTime, dataPoint.realEndTime);
  customTooltip.innerHTML = `
    <div style="font-weight: 700; margin-bottom: 6px; color: rgb(31, 41, 55); font-size: 16px;">Estado ${dataPoint.y}</div>
    <div style="margin-bottom: 2px; color: rgb(31, 41, 55); font-size: 12px; font-weight: 400;">Fecha: ${formatDate(dataPoint.realStartTime)}</div>
    <div style="margin-bottom: 2px; color: rgb(31, 41, 55); font-size: 12px; font-weight: 400;">Horario: ${timeRange}</div>
    <div style="margin-bottom: 2px; color: rgb(31, 41, 55); font-size: 12px; font-weight: 400;">Duraci√≥n: ${dataPoint.duration}</div>
    <div style="color: rgb(31, 41, 55); font-size: 12px; font-weight: 400;">Velocidad: ${speedDisplay}</div>
  `;
  
  // Posicionar tooltip cerca del cursor (usar coordenadas del evento nativo)
  const clientX = event.native ? event.native.clientX : event.clientX;
  const clientY = event.native ? event.native.clientY : event.clientY;
  
  customTooltip.style.left = (clientX + 10) + 'px';
  customTooltip.style.top = (clientY - 10) + 'px';
  
  // A√±adir al DOM
  document.body.appendChild(customTooltip);
  console.log('Tooltip a√±adido al DOM'); // Debug
}

// Funci√≥n para ocultar tooltip personalizado
function hideCustomTooltip() {
  if (customTooltip) {
    customTooltip.remove();
    customTooltip = null;
  }
}

// Variables y funciones para el gr√°fico de velocidad
let originalSpeedIntervals = []; // Guardar los intervalos con velocidad para referencia
let customSpeedTooltip = null;

// Funci√≥n para actualizar el punto din√°mico del gr√°fico de velocidad
function updateSpeedDynamicPoint(event) {
  if (!speedChart || !originalSpeedIntervals.length) return;
  
  // Obtener coordenadas del mouse
  const canvasX = event.native.offsetX;
  const xScale = speedChart.scales.x;
  
  if (!xScale) return;
  
  // Convertir coordenada X a valor de tiempo
  const xValue = xScale.getValueForPixel(canvasX);
  
  // Buscar el intervalo correspondiente
  const baseTime = originalSpeedIntervals[0].start.getTime();
  let targetInterval = null;
  
  for (let i = 0; i < originalSpeedIntervals.length; i++) {
    const interval = originalSpeedIntervals[i];
    const startMinutes = (interval.start.getTime() - baseTime) / (1000 * 60);
    const endMinutes = (interval.end.getTime() - baseTime) / (1000 * 60);
    
    if (xValue >= startMinutes && xValue <= endMinutes) {
      targetInterval = interval;
      break;
    }
  }
  
  if (targetInterval) {
    // Usar velocidad del intervalo, o 0 si no hay datos
    const speedValue = (targetInterval.avgSpeed !== null && targetInterval.avgSpeed !== undefined && !isNaN(targetInterval.avgSpeed)) 
      ? targetInterval.avgSpeed 
      : 0;
      
    // Actualizar el dataset del punto din√°mico
    speedChart.data.datasets[1].data = [{
      x: xValue,
      y: speedValue
    }];
    speedChart.update('none'); // Sin animaci√≥n para fluidez
  } else {
    // Ocultar punto si no hay intervalo
    speedChart.data.datasets[1].data = [];
    speedChart.update('none');
  }
}

// Funci√≥n para obtener datos del punto din√°mico del gr√°fico de velocidad
function getSpeedDynamicPointData(event) {
  if (!originalSpeedIntervals.length) return null;
  
  const canvasX = event.native.offsetX;
  const xScale = speedChart.scales.x;
  
  if (!xScale) return null;
  
  const xValue = xScale.getValueForPixel(canvasX);
  const baseTime = originalSpeedIntervals[0].start.getTime();
  
  for (let i = 0; i < originalSpeedIntervals.length; i++) {
    const interval = originalSpeedIntervals[i];
    const startMinutes = (interval.start.getTime() - baseTime) / (1000 * 60);
    const endMinutes = (interval.end.getTime() - baseTime) / (1000 * 60);
    
    if (xValue >= startMinutes && xValue <= endMinutes) {
      return {
        y: interval.state,
        startTime: formatTime(interval.start),
        endTime: formatTime(interval.end),
        duration: calculateVisualDuration(interval.start, interval.end),
        realStartTime: interval.start,
        realEndTime: interval.end,
        avgSpeed: interval.avgSpeed,
        hasSpeedData: interval.avgSpeed !== null && interval.avgSpeed !== undefined && !isNaN(interval.avgSpeed)
      };
    }
  }
  
  return null;
}

// Funci√≥n para mostrar tooltip personalizado del gr√°fico de velocidad
function showSpeedCustomTooltip(event, dataPoint) {
  hideSpeedCustomTooltip(); // Ocultar tooltip anterior si existe
  
  // Verificar que tenemos datos v√°lidos
  if (!dataPoint) {
    return;
  }
  
  // Crear elemento tooltip
  customSpeedTooltip = document.createElement('div');
  customSpeedTooltip.style.position = 'fixed';
  customSpeedTooltip.style.backgroundColor = 'white';
  customSpeedTooltip.style.color = 'rgb(55, 65, 81)';
  customSpeedTooltip.style.padding = '8px 12px';
  customSpeedTooltip.style.borderRadius = '6px';
  customSpeedTooltip.style.fontSize = '14px';
  customSpeedTooltip.style.fontWeight = '500';
  customSpeedTooltip.style.border = '1px solid rgb(209, 213, 219)';
  customSpeedTooltip.style.boxShadow = '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)';
  customSpeedTooltip.style.zIndex = '1000';
  customSpeedTooltip.style.pointerEvents = 'none';
  customSpeedTooltip.style.whiteSpace = 'nowrap';
  
  // Formatear velocidad
  const speedDisplay = dataPoint.hasSpeedData 
    ? `${dataPoint.avgSpeed.toFixed(2)} nudos`
    : 'Sin datos';
  
  const speedColor = dataPoint.hasSpeedData 
    ? 'rgb(34, 197, 94)' 
    : 'rgb(156, 163, 175)'; // gris para sin datos

  // Contenido del tooltip
  const timeRange = formatTimeRange(dataPoint.realStartTime, dataPoint.realEndTime);
  customSpeedTooltip.innerHTML = `
    <div style="font-weight: 700; margin-bottom: 6px; color: rgb(31, 41, 55); font-size: 16px;">Estado ${dataPoint.y}</div>
    <div style="margin-bottom: 2px; color: rgb(31, 41, 55); font-size: 12px; font-weight: 400;">Fecha: ${formatDate(dataPoint.realStartTime)}</div>
    <div style="margin-bottom: 2px; color: rgb(31, 41, 55); font-size: 12px; font-weight: 400;">Horario: ${timeRange}</div>
    <div style="margin-bottom: 2px; color: rgb(31, 41, 55); font-size: 12px; font-weight: 400;">Duraci√≥n: ${dataPoint.duration}</div>
    <div style="color: rgb(31, 41, 55); font-size: 12px; font-weight: 400;">Velocidad: ${speedDisplay}</div>
  `;
  
  // Posicionar tooltip cerca del cursor
  const clientX = event.native ? event.native.clientX : event.clientX;
  const clientY = event.native ? event.native.clientY : event.clientY;
  
  customSpeedTooltip.style.left = (clientX + 10) + 'px';
  customSpeedTooltip.style.top = (clientY - 10) + 'px';
  
  // A√±adir al DOM
  document.body.appendChild(customSpeedTooltip);
}

// Funci√≥n para ocultar tooltip personalizado del gr√°fico de velocidad
function hideSpeedCustomTooltip() {
  if (customSpeedTooltip) {
    customSpeedTooltip.remove();
    customSpeedTooltip = null;
  }
}

 // Ocultar tooltip al hacer clic fuera de la gr√°fica
 document.addEventListener('click', function(event) {
   if (!chartCanvas.contains(event.target)) {
     hideCustomTooltip();
   }
 });

 // Ocultar punto din√°mico cuando el mouse sale del canvas
 chartCanvas.addEventListener('mouseleave', function() {
   if (stateChart) {
     stateChart.data.datasets[1].data = [];
     stateChart.update('none');
   }
   hideCustomTooltip();
 });

 // Ocultar punto din√°mico del gr√°fico de velocidad cuando el mouse sale del canvas
 speedChartCanvas.addEventListener('mouseleave', function() {
   if (speedChart) {
     speedChart.data.datasets[1].data = [];
     speedChart.update('none');
   }
   hideSpeedCustomTooltip();
 });

 // Ocultar tooltips al hacer clic fuera de ambos gr√°ficos
 document.addEventListener('click', function(event) {
   if (!chartCanvas.contains(event.target) && !speedChartCanvas.contains(event.target)) {
     hideCustomTooltip();
     hideSpeedCustomTooltip();
   }
 });

let ROWS_BY_SHEET = {};
let ACTIVE_SHEET = null;

function parseCSV(text){
  const rows=[]; let row=[]; let cur=''; let inQ=false;
  const flush=()=>{ row.push(cur); cur=''; };
  const endRow=()=>{ flush(); rows.push(row); row=[]; };
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(inQ){
      if(ch==='"' && nx==='"'){ cur+='"'; i++; }
      else if(ch==='"'){ inQ=false; }
      else cur+=ch;
    }else{
      if(ch==='"') inQ=true;
      else if(ch===',') flush();
      else if(ch==='\n') endRow();
      else if(ch==='\r'){} else cur+=ch;
    }
  }
  flush(); if(row.length) rows.push(row);
  return rows;
}

function parseToDate(v){
  if (v==null || v==='') return null;
  if (Object.prototype.toString.call(v)==='[object Date]' && !isNaN(v)) return v;
  if (typeof v==='number' && isFinite(v)){
    const epoch = new Date(Date.UTC(1899,11,30)).getTime();
    return new Date(epoch + v*86400000);
  }
  const s=String(v).trim();
  const d1=new Date(s); if(!isNaN(d1)) return d1;
  return null;
}

function pad2(n){ return String(n).padStart(2,'0'); }
function formatDate(d){ return `${pad2(d.getDate())}/${pad2(d.getMonth()+1)}/${d.getFullYear()}`; }
function formatTime(d){ 
  return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
}

// Funci√≥n mejorada para mostrar tiempo con m√°s contexto
function formatTimeWithLabel(d) {
  const hours = d.getHours();
  const minutes = d.getMinutes();
  return `${pad2(hours)}:${pad2(minutes)}h`;
}

// Funci√≥n para formatear en 12 horas (AM/PM)
function formatTime12h(d) {
  const hours = d.getHours();
  const minutes = d.getMinutes();
  const seconds = d.getSeconds();
  const ampm = hours >= 12 ? 'PM' : 'AM';
  const hours12 = hours % 12;
  const displayHours = hours12 ? hours12 : 12;
  return `${displayHours}:${pad2(minutes)}:${pad2(seconds)} ${ampm}`;
}

// Variable global para el formato de tiempo (24h por defecto, m√°s com√∫n internacionalmente)
let use24HourFormat = true;

// Funci√≥n para obtener el tiempo formateado seg√∫n la preferencia
function getFormattedTime(d) {
  return use24HourFormat ? formatTime(d) : formatTime12h(d);
}

// Funci√≥n para mostrar rango de tiempo m√°s claro
function formatTimeRange(startDate, endDate) {
  const startTime = getFormattedTime(startDate);
  const endTime = getFormattedTime(endDate);
  const startDateStr = formatDate(startDate);
  const endDateStr = formatDate(endDate);
  
  // Si es el mismo d√≠a, solo mostrar las horas
  if (startDateStr === endDateStr) {
    return `${startTime} - ${endTime}`;
  } else {
    // Si son d√≠as diferentes, mostrar fecha tambi√©n
    return `${startTime} (${startDateStr}) - ${endTime} (${endDateStr})`;
  }
}
function msToHM(ms){
  if(!isFinite(ms)) return '';
  ms=Math.max(0,ms);
  // Usar truncamiento en lugar de redondeo para evitar duraciones infladas
  let totalMin=Math.floor(ms/60000);
  let h=Math.floor(totalMin/60);
  let m=totalMin%60;
  return `${h}:${pad2(m)}`;
}

// Funci√≥n para formatear duraci√≥n con precisi√≥n de segundos
function formatDynamicDuration(totalSeconds) {
  if (totalSeconds < 60) {
    // Mostrar en segundos si es menos de 1 minuto
    return `${totalSeconds}seg`;
  } else if (totalSeconds < 3600) {
    // Mostrar en minutos si es menos de 1 hora
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    if (seconds === 0) {
      return `${minutes}min`;
    } else {
      return `${minutes}min ${seconds}seg`;
    }
  } else {
    // Mostrar en horas si es 1 hora o m√°s
    const hours = Math.floor(totalSeconds / 3600);
    const remainingSeconds = totalSeconds % 3600;
    const minutes = Math.floor(remainingSeconds / 60);
    const seconds = remainingSeconds % 60;
    
    let result = `${hours}h`;
    if (minutes > 0) result += ` ${minutes}min`;
    if (seconds > 0) result += ` ${seconds}seg`;
    
    return result;
  }
}

// Nueva funci√≥n para calcular duraci√≥n real basada en timestamps completos
function calculateVisualDuration(startDate, endDate) {
  // Calcular diferencia en milisegundos
  const diffMs = endDate.getTime() - startDate.getTime();
  
  // Convertir a segundos totales (redondeando al m√°s cercano para mayor precisi√≥n)
  let diffSec = Math.round(diffMs / 1000);
  
  // Asegurar que intervalos v√°lidos muestren al menos 1 segundo
  if (diffSec === 0 && diffMs > 0) {
    diffSec = 1;
  }
  
  // Usar formateo din√°mico con precisi√≥n de segundos
  return formatDynamicDuration(diffSec);
}

function buildRecords(rows){
  const rec=[];
  for(let r=1;r<rows.length;r++){
    const tRaw=rows[r][0]; const sRaw=rows[r][1]; const speedRaw=rows[r][2];
    if(sRaw==null||sRaw==='') continue;
    const d=parseToDate(tRaw); if(!d) continue;
    const state=Number(String(sRaw).replace(',', '.'));
    if(!isFinite(state)) continue;
    
    // Agregar velocidad si est√° disponible
    let speed = null;
    if(speedRaw != null && speedRaw !== '') {
      const speedNum = Number(String(speedRaw).replace(',', '.'));
      if(isFinite(speedNum)) {
        speed = speedNum;
      }
    }
    
    rec.push({date:d, state:Math.trunc(state), speed:speed});
  }
  rec.sort((a,b)=>a.date-b.date);
  return rec;
}

function computeIntervals(records){
  if(!records.length) return [];
  const intervals=[]; let startIdx=0; let prevState=records[0].state;
  
  // Funci√≥n para calcular velocidad media de un rango de registros
  function calculateAverageSpeed(startIndex, endIndex) {
    const speeds = [];
    for(let j = startIndex; j <= endIndex; j++) {
      if(records[j] && records[j].speed !== null && !isNaN(records[j].speed)) {
        speeds.push(records[j].speed);
      }
    }
    if(speeds.length === 0) return null;
    return speeds.reduce((sum, speed) => sum + speed, 0) / speeds.length;
  }
  
  // Funci√≥n para detectar gaps significativos (‚â• 5 minutos)
  function detectSignificantGap(prevDate, currentDate) {
    const gapMs = currentDate.getTime() - prevDate.getTime();
    const threshold = 5 * 60 * 1000; // 5 minutos en milisegundos
    
    const isGap = gapMs >= threshold;
    
    if (isGap) {
      const gapMinutes = (gapMs / (1000 * 60)).toFixed(1);
      console.log(`üîç Gap significativo detectado: ${gapMinutes} min entre ${formatTime(prevDate)} y ${formatTime(currentDate)}`);
    }
    
    return isGap;
  }
  
  for(let i=1;i<records.length;i++){
    // Verificar si hay un gap significativo entre registros consecutivos (‚â• 5 minutos)
    const hasGap = detectSignificantGap(records[i-1].date, records[i].date);
    
    if(records[i].state!==prevState || hasGap){
      const avgSpeed = calculateAverageSpeed(startIdx, i-1);
      intervals.push({
        state: prevState, 
        start: records[startIdx].date, 
        end: records[i-1].date,  // El intervalo termina en el √∫ltimo registro del estado actual
        avgSpeed: avgSpeed,
        recordCount: i - startIdx,
        isGapBefore: hasGap && records[i].state === prevState // Marcar si este intervalo fue cortado por un gap
      });
      
      // Si hay gap pero el estado no cambi√≥, marcar que el siguiente intervalo empieza despu√©s de un gap
      if(hasGap && records[i].state === prevState) {
        console.log(`Gap detectado entre ${formatTime(records[i-1].date)} y ${formatTime(records[i].date)} (duraci√≥n: ${((records[i].date.getTime() - records[i-1].date.getTime()) / (1000 * 60)).toFixed(1)} min)`);
      }
      
      startIdx=i; prevState=records[i].state;
    }
  }
  
  // √öltimo intervalo: terminar exactamente en el √∫ltimo dato disponible
  const lastStart = records[startIdx].date;
  const lastEnd = records[records.length-1].date;
  
  const lastAvgSpeed = calculateAverageSpeed(startIdx, records.length-1);
  intervals.push({
    state: prevState, 
    start: lastStart, 
    end: lastEnd,
    avgSpeed: lastAvgSpeed,
    recordCount: records.length - startIdx,
    isGapBefore: false
  });
  
  return intervals;
}

function renderIntervals(intervals){
  if(!intervals.length){ 
    outTable.innerHTML='<div class="text-center py-8 text-gray-500">(sin datos)</div>'; 
    toggleDashboard(false);
    return; 
  }
  
  // Detectar gaps para mostrar informaci√≥n
  const gaps = [];
  for (let i = 1; i < intervals.length; i++) {
    const prevEnd = intervals[i-1].end.getTime();
    const currentStart = intervals[i].start.getTime();
    const gapDuration = currentStart - prevEnd;
    
    if (gapDuration >= 5 * 60 * 1000) {
      gaps.push({
        index: i,
        start: new Date(prevEnd),
        end: new Date(currentStart),
        duration: gapDuration,
        durationFormatted: formatDynamicDuration(Math.round(gapDuration / 1000))
      });
    }
  }
  
  // Obtener el rango de fechas para mostrar en los headers
  const dateRange = getDateRange(intervals);
  
  // Mostrar el dashboard
  toggleDashboard(true);
  
  // Mostrar informaci√≥n de gaps detectados si los hay (solo en consola)
  if (gaps.length > 0) {
    console.log(`üîç Se detectaron ${gaps.length} gaps en los datos:`);
    gaps.forEach((gap, index) => {
      console.log(`  Gap ${index + 1}: ${formatTime(gap.start)} - ${formatTime(gap.end)} (${gap.durationFormatted})`);
    });
  }
  
  // Crear gr√°ficos
  createChart(intervals);
  createPieChart(intervals);
  createSpeedChart(intervals);
  
  let html='<thead class="bg-dark-card/50 sticky top-0 z-10">';
  // Incluir fecha cuando hay m√∫ltiples fechas
  html += '<tr class="border-b border-dark-border">';
  html += '<th class="px-6 py-4 text-left text-sm font-semibold text-text-primary bg-dark-card/50">Estado</th>';
  
  // Mostrar fecha solo si hay m√∫ltiples fechas
  const hasMultipleDates = dateRange.includes(' - ');
  if (hasMultipleDates) {
    html += '<th class="px-6 py-4 text-left text-sm font-semibold text-text-primary bg-dark-card/50">Fecha</th>';
  }
  
  html += '<th class="px-6 py-4 text-left text-sm font-semibold text-text-primary bg-dark-card/50">Horario</th>';
  html += '<th class="px-6 py-4 text-left text-sm font-semibold text-text-primary bg-dark-card/50">Duraci√≥n</th>';
  html += '<th class="px-6 py-4 text-left text-sm font-semibold text-text-primary bg-dark-card/50">Velocidad Media</th>';
  html += '</tr></thead><tbody class="divide-y divide-dark-border bg-dark-card/20">';
  
   let currentDate = null;
     for(let idx = 0; idx < intervals.length; idx++){
     const it = intervals[idx];
     
     // Verificar si hay un gap antes de este intervalo
     const gapBefore = gaps.find(gap => gap.index === idx);
     
     // Mostrar fila de gap si existe
     if (gapBefore) {
       const gapRowClass = 'bg-gray-800/30 border-l-4 border-gray-500';
       html += `<tr class="${gapRowClass}">`;
       html += `<td class="px-6 py-4 text-sm font-medium text-gray-400">
         <span class="inline-flex items-center justify-center px-3 py-1 text-xs font-semibold rounded-lg bg-gray-600/20 text-gray-400 border border-gray-600/30">
           <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
             <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z"></path>
           </svg>
           GAP
         </span>
       </td>`;
       
       if (hasMultipleDates) {
         html += `<td class="px-6 py-4 text-sm text-gray-400">${formatDate(gapBefore.start)}</td>`;
       }
       
       const gapTimeRange = formatTimeRange(gapBefore.start, gapBefore.end);
       html += `<td class="px-6 py-4 text-sm text-gray-400 font-medium">${gapTimeRange}</td>`;
       html += `<td class="px-6 py-4 text-sm text-gray-400 font-semibold italic">${gapBefore.durationFormatted}</td>`;
       html += `<td class="px-6 py-4 text-sm text-gray-500 italic">Sin datos</td>`;
       html += `</tr>`;
     }
     
     // Calcular duraci√≥n basada en las horas mostradas (HH:MM)
     const visualDuration = calculateVisualDuration(it.start, it.end);
     const intervalDate = formatDate(it.start);
     
     // Detectar cambio de d√≠a para a√±adir separaci√≥n visual
     const isNewDay = currentDate && currentDate !== intervalDate;
     const rowClass = 'hover:bg-dark-card/40 transition-colors duration-200';
     
     html += `<tr class="${rowClass}">`;
     html += `<td class="px-6 py-4 text-sm font-medium text-text-primary">${getStateBadge(it.state)}</td>`;
     
     // Mostrar fecha solo si hay m√∫ltiples fechas
     if (hasMultipleDates) {
       const dateClass = isNewDay ? 'px-6 py-4 text-sm text-white font-semibold' : 'px-6 py-4 text-sm text-text-primary';
       html += `<td class="${dateClass}">${intervalDate}</td>`;
     }
     
     const timeRangeForTable = formatTimeRange(it.start, it.end);
     html += `<td class="px-6 py-4 text-sm text-text-primary font-medium">${timeRangeForTable}</td>`;
     html += `<td class="px-6 py-4 text-sm text-text-primary font-semibold">${visualDuration}</td>`;
     
     // Mostrar velocidad media del intervalo
     const speedDisplay = it.avgSpeed !== null && !isNaN(it.avgSpeed) 
       ? `${it.avgSpeed.toFixed(2)} nudos` 
       : '<span class="text-text-muted">N/A</span>';
     html += `<td class="px-6 py-4 text-sm text-text-primary">${speedDisplay}</td>`;
    
    html += `</tr>`;
     
     currentDate = intervalDate;
   }
  html+='</tbody>';
  outTable.innerHTML = html;
}

function getStateBadge(state) {
  const getStateStyles = (state) => {
    switch(state) {
      case 0:
        return "bg-gray-500/20 text-gray-400 border border-gray-500/30";
      case 1:
        return "bg-green-500/20 text-green-400 border border-green-500/30";
      case 2:
        return "bg-blue-500/20 text-blue-400 border border-blue-500/30";
      case 3:
        return "bg-orange-500/20 text-orange-400 border border-orange-500/30";
      case 4:
        return "bg-red-500/20 text-red-400 border border-red-500/30";
      case 5:
        return "bg-purple-500/20 text-purple-400 border border-purple-500/30";
      case 6:
        return "bg-pink-500/20 text-pink-400 border border-pink-500/30";
      case 7:
        return "bg-cyan-500/20 text-cyan-400 border border-cyan-500/30";
      case 8:
        return "bg-lime-500/20 text-lime-400 border border-lime-500/30";
      default:
        return "bg-gray-500/20 text-gray-400 border border-gray-500/30";
    }
  }
  
  return `<span class="inline-flex items-center justify-center px-4 py-2 text-sm font-semibold rounded-lg transition-all duration-200 min-w-[70px] text-center ${getStateStyles(state)} hover:scale-105">${state}</span>`;
}

fileInput.addEventListener('change', async (e)=>{
  const files = Array.from(e.target.files || []);
  if (!files.length) return;
  
  info.textContent = `Procesando ${files.length} archivo(s)...`;
  
  for (const file of files) {
    try {
      const ab = await file.arrayBuffer();
      const name = file.name.toLowerCase();
      let fileContent = '';
      let records = [];
      
      if (name.endsWith('.csv')) {
        const text = new TextDecoder('utf-8').decode(ab);
        fileContent = text;
        const rows = parseCSV(text);
        records = buildRecords(rows);
      } else {
        if (typeof XLSX === 'undefined') {
          info.textContent = '‚ùå Error: Librer√≠a XLSX no disponible. Recargue la p√°gina.';
          console.error('XLSX no est√° disponible para procesar:', file.name);
          continue;
        }
        const wb = XLSX.read(ab, {type: 'array', cellDates: true, cellNF: true, cellText: false});
        // Para Excel, usar la primera hoja
        const firstSheet = wb.SheetNames[0];
        const sh = wb.Sheets[firstSheet];
        const rows = XLSX.utils.sheet_to_json(sh, {header: 1, raw: true, defval: ''});
        fileContent = JSON.stringify(rows);
        records = buildRecords(rows);
      }
      
      // Verificar si el archivo ya est√° cargado
      if (isFileDuplicate(fileContent, file.name)) {
        info.textContent = `Archivo duplicado omitido: ${file.name}`;
        continue;
      }
      
      // Agregar archivo a la lista
      const hash = generateFileHash(fileContent, file.name);
      loadedFiles.push({
        name: file.name,
        data: records,
        hash: hash,
        recordCount: records.length
      });
      
    } catch (error) {
      console.error(`Error procesando ${file.name}:`, error);
      info.textContent = `Error procesando ${file.name}`;
    }
  }
  
  // Actualizar la interfaz
  updateUnifiedData();
  updateFilesList();
  updateProcessButton();
  
  // Ocultar secciones de resultados al cargar nuevos archivos
  toggleDashboard(false);
  sheetContainer.classList.add('hidden');
  
  // Limpiar el input para permitir recargar el mismo archivo
  fileInput.value = '';
});



goBtn.addEventListener('click', ()=>{
  if (loadedFiles.length === 0) {
    info.textContent = 'No hay archivos cargados para procesar';
    return;
  }
  
  // Usar los datos unificados de todos los archivos
  const intervals = computeIntervals(UNIFIED_DATA);
  renderIntervals(intervals);
});




// Inicializar controles de zoom
setupZoomControls();
</script>

</body>
</html>
